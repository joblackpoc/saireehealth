"""
OWASP Security Views
Secure view implementations following OWASP guidelines
"""

import json
import logging
from typing import Dict, Any, Optional
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView, FormView
from django.http import HttpResponse, JsonResponse, HttpRequest
from django.core.exceptions import ValidationError, SuspiciousOperation
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.cache import never_cache
from django.views.decorators.http import require_http_methods
from django.utils.decorators import method_decorator
from django.contrib import messages
from django.core.cache import cache
from django.utils import timezone
from django.conf import settings
import time
from security_enhancements.secure_forms import SecureLoginForm, SecureRegistrationForm
from security_enhancements.secure_auth import (
    MultiFactorAuthentication, SessionSecurity, AuthenticationLogger
)
from security_enhancements.validators import InputValidator

logger = logging.getLogger('security_enhancements')

class SecurityMixin:\n    """Mixin for adding security features to views"""\n    \n    def dispatch(self, request, *args, **kwargs):\n        """Enhanced dispatch with security checks"""\n        \n        # Rate limiting\n        if not self._check_rate_limit(request):\n            logger.warning(f"Rate limit exceeded for {self._get_client_ip(request)}")\n            return HttpResponse('Rate Limit Exceeded', status=429)\n        \n        # Session validation\n        if request.user.is_authenticated and not SessionSecurity.validate_session(request):\n            logout(request)\n            messages.error(request, 'Your session has expired for security reasons.')\n            return redirect('accounts:login')\n        \n        # Input validation\n        if not self._validate_request_inputs(request):\n            raise SuspiciousOperation("Invalid request data detected")\n        \n        return super().dispatch(request, *args, **kwargs)\n    \n    def _check_rate_limit(self, request: HttpRequest) -> bool:\n        """Check rate limiting for the view"""\n        ip_address = self._get_client_ip(request)\n        view_name = self.__class__.__name__\n        \n        # Different limits for different view types\n        rate_limits = {\n            'SecureLoginView': 5,      # 5 attempts per minute\n            'SecureRegistrationView': 3,  # 3 attempts per minute\n            'default': 60              # 60 requests per minute\n        }\n        \n        limit = rate_limits.get(view_name, rate_limits['default'])\n        \n        cache_key = f"rate_limit:{view_name}:{ip_address}"\n        current_requests = cache.get(cache_key, 0)\n        \n        if current_requests >= limit:\n            return False\n        \n        # Increment counter\n        cache.set(cache_key, current_requests + 1, 60)  # 60 second window\n        return True\n    \n    def _get_client_ip(self, request: HttpRequest) -> str:\n        """Get client IP address"""\n        forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')\n        if forwarded_for:\n            return forwarded_for.split(',')[0].strip()\n        return request.META.get('REMOTE_ADDR', 'unknown')\n    \n    def _validate_request_inputs(self, request: HttpRequest) -> bool:\n        """Validate request inputs for security"""\n        # Validate GET parameters\n        for param_name, param_value in request.GET.items():\n            if not InputValidator.validate_input(str(param_value)):\n                logger.warning(f"Malicious input in GET parameter {param_name}: {param_value}")\n                return False\n        \n        # Validate POST parameters\n        if hasattr(request, 'POST'):\n            for field_name, field_value in request.POST.items():\n                if field_name != 'csrfmiddlewaretoken':  # Skip CSRF token\n                    if not InputValidator.validate_input(str(field_value)):\n                        logger.warning(f"Malicious input in POST field {field_name}: {field_value}")\n                        return False\n        \n        return True


@method_decorator([csrf_protect, never_cache], name='dispatch')\nclass SecureLoginView(SecurityMixin, FormView):\n    """Secure login view with enhanced protection"""\n    \n    template_name = 'accounts/login.html'\n    form_class = SecureLoginForm\n    success_url = '/health/dashboard/'\n    \n    def get_form_kwargs(self):\n        """Add request to form kwargs"""\n        kwargs = super().get_form_kwargs()\n        kwargs['request'] = self.request\n        return kwargs\n    \n    def form_valid(self, form):\n        """Handle valid login form"""\n        username = form.cleaned_data['username']\n        password = form.cleaned_data['password']\n        \n        # Authenticate user\n        user = authenticate(\n            self.request,\n            username=username,\n            password=password\n        )\n        \n        if user is not None:\n            # Check if user requires MFA\n            if self._requires_mfa(user):\n                # Store user ID in session for MFA verification\n                self.request.session['mfa_user_id'] = user.id\n                self.request.session['mfa_timestamp'] = time.time()\n                return redirect('accounts:mfa_verify')\n            \n            # Standard login\n            login(self.request, user)\n            \n            # Create secure session\n            SessionSecurity.create_secure_session(self.request, user)\n            \n            # Log successful login\n            AuthenticationLogger.log_login_attempt(\n                username, self._get_client_ip(self.request), True\n            )\n            \n            messages.success(self.request, 'Login successful!')\n            \n            # Redirect to next URL or default\n            next_url = self.request.GET.get('next', self.success_url)\n            return redirect(next_url)\n        \n        else:\n            # Log failed login\n            AuthenticationLogger.log_login_attempt(\n                username, self._get_client_ip(self.request), False\n            )\n            \n            messages.error(self.request, 'Invalid username or password.')\n            return self.form_invalid(form)\n    \n    def form_invalid(self, form):\n        """Handle invalid login form"""\n        # Add delay to prevent brute force attacks\n        time.sleep(1)\n        \n        return super().form_invalid(form)\n    \n    def _requires_mfa(self, user) -> bool:\n        """Check if user requires multi-factor authentication"""\n        # Check if user has MFA enabled\n        return hasattr(user, 'userprofile') and getattr(user.userprofile, 'mfa_enabled', False)\n\n\n@method_decorator([csrf_protect, never_cache], name='dispatch')\nclass SecureRegistrationView(SecurityMixin, FormView):\n    """Secure user registration view"""\n    \n    template_name = 'accounts/register.html'\n    form_class = SecureRegistrationForm\n    success_url = '/accounts/login/'\n    \n    def form_valid(self, form):\n        """Handle valid registration form"""\n        # Check registration rate limiting\n        if not self._check_registration_limit():\n            messages.error(self.request, 'Registration temporarily unavailable. Please try again later.')\n            return self.form_invalid(form)\n        \n        # Save user\n        user = form.save()\n        \n        # Log registration\n        logger.info(f"User registration: {user.username} from {self._get_client_ip(self.request)}")\n        \n        messages.success(self.request, 'Registration successful! Please log in.')\n        return redirect(self.success_url)\n    \n    def _check_registration_limit(self) -> bool:\n        """Check registration rate limiting"""\n        ip_address = self._get_client_ip(self.request)\n        cache_key = f"registration_limit:{ip_address}"\n        \n        registrations_today = cache.get(cache_key, 0)\n        \n        if registrations_today >= 3:  # Max 3 registrations per day per IP\n            return False\n        \n        cache.set(cache_key, registrations_today + 1, 86400)  # 24 hours\n        return True\n\n\n@method_decorator([csrf_protect, never_cache], name='dispatch')\nclass MFAVerificationView(SecurityMixin, TemplateView):\n    """Multi-Factor Authentication verification view"""\n    \n    template_name = 'accounts/mfa_verify.html'\n    \n    def dispatch(self, request, *args, **kwargs):\n        """Check MFA session validity"""\n        if 'mfa_user_id' not in request.session:\n            return redirect('accounts:login')\n        \n        # Check MFA session timeout (5 minutes)\n        mfa_timestamp = request.session.get('mfa_timestamp', 0)\n        if time.time() - mfa_timestamp > 300:\n            del request.session['mfa_user_id']\n            del request.session['mfa_timestamp']\n            messages.error(request, 'MFA session expired. Please log in again.')\n            return redirect('accounts:login')\n        \n        return super().dispatch(request, *args, **kwargs)\n    \n    def post(self, request, *args, **kwargs):\n        """Handle MFA verification"""\n        token = request.POST.get('mfa_token', '').strip()\n        \n        if not token:\n            messages.error(request, 'Please enter your authentication code.')\n            return self.get(request, *args, **kwargs)\n        \n        # Get user from session\n        try:\n            from django.contrib.auth import get_user_model\n            User = get_user_model()\n            user = User.objects.get(id=request.session['mfa_user_id'])\n        except User.DoesNotExist:\n            messages.error(request, 'Invalid session. Please log in again.')\n            return redirect('accounts:login')\n        \n        # Verify MFA token\n        if self._verify_mfa_token(user, token):\n            # Complete login\n            login(request, user)\n            \n            # Create secure session\n            SessionSecurity.create_secure_session(request, user)\n            \n            # Clean up MFA session data\n            del request.session['mfa_user_id']\n            del request.session['mfa_timestamp']\n            \n            # Log successful MFA\n            AuthenticationLogger.log_mfa_event(\n                user.username, self._get_client_ip(request), 'verify', True\n            )\n            \n            messages.success(request, 'Authentication successful!')\n            return redirect('/health/dashboard/')\n        \n        else:\n            # Log failed MFA\n            AuthenticationLogger.log_mfa_event(\n                user.username, self._get_client_ip(request), 'verify', False\n            )\n            \n            # Increment failed attempts\n            attempts_key = f"mfa_attempts:{user.id}"\n            attempts = cache.get(attempts_key, 0) + 1\n            cache.set(attempts_key, attempts, 900)  # 15 minutes\n            \n            if attempts >= 3:\n                # Lock MFA after 3 failed attempts\n                del request.session['mfa_user_id']\n                del request.session['mfa_timestamp']\n                messages.error(request, 'Too many failed attempts. Please log in again.')\n                return redirect('accounts:login')\n            \n            messages.error(request, f'Invalid authentication code. {3 - attempts} attempts remaining.')\n            return self.get(request, *args, **kwargs)\n    \n    def _verify_mfa_token(self, user, token: str) -> bool:\n        """Verify MFA token"""\n        if not hasattr(user, 'userprofile') or not user.userprofile.mfa_secret:\n            return False\n        \n        return MultiFactorAuthentication.verify_totp(user.userprofile.mfa_secret, token)\n\n\n@login_required\ndef secure_logout_view(request):\n    """Secure logout view"""\n    if request.method == 'POST':\n        username = request.user.username if request.user.is_authenticated else 'anonymous'\n        ip_address = request.META.get('HTTP_X_FORWARDED_FOR', \n                                    request.META.get('REMOTE_ADDR', 'unknown')).split(',')[0].strip()\n        \n        # Log logout\n        AuthenticationLogger.log_logout(username, ip_address)\n        \n        # Clear session data\n        request.session.flush()\n        \n        # Logout user\n        logout(request)\n        \n        messages.success(request, 'You have been logged out successfully.')\n        return redirect('accounts:login')\n    \n    return render(request, 'accounts/logout_confirm.html')\n\n\n@method_decorator([csrf_protect, never_cache], name='dispatch')\nclass SecurityDashboardView(LoginRequiredMixin, SecurityMixin, TemplateView):\n    """Security dashboard for monitoring"""\n    \n    template_name = 'security/dashboard.html'\n    login_url = '/accounts/login/'\n    \n    def get_context_data(self, **kwargs):\n        """Add security metrics to context"""\n        context = super().get_context_data(**kwargs)\n        \n        context.update({\n            'user_sessions': self._get_user_sessions(),\n            'recent_logins': self._get_recent_logins(),\n            'security_events': self._get_security_events(),\n            'mfa_status': self._get_mfa_status(),\n        })\n        \n        return context\n    \n    def _get_user_sessions(self) -> Dict[str, Any]:\n        """Get user session information"""\n        # This would integrate with your session storage\n        return {\n            'active_sessions': 1,\n            'session_created': timezone.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'last_activity': timezone.now().strftime('%Y-%m-%d %H:%M:%S')\n        }\n    \n    def _get_recent_logins(self) -> list:\n        """Get recent login attempts"""\n        # This would query your security logs\n        return [\n            {\n                'timestamp': timezone.now().strftime('%Y-%m-%d %H:%M:%S'),\n                'ip_address': self._get_client_ip(self.request),\n                'success': True\n            }\n        ]\n    \n    def _get_security_events(self) -> list:\n        """Get recent security events"""\n        return []\n    \n    def _get_mfa_status(self) -> Dict[str, Any]:\n        """Get MFA status for user"""\n        user = self.request.user\n        mfa_enabled = hasattr(user, 'userprofile') and getattr(user.userprofile, 'mfa_enabled', False)\n        \n        return {\n            'enabled': mfa_enabled,\n            'setup_url': '/accounts/mfa/setup/' if not mfa_enabled else None\n        }\n\n\n@require_http_methods(["POST"])\n@csrf_protect\ndef api_security_check(request):\n    """API endpoint for security validation"""\n    try:\n        # Validate request\n        if not InputValidator.validate_json_input(request.body.decode('utf-8')):\n            return JsonResponse({'error': 'Invalid JSON input'}, status=400)\n        \n        data = json.loads(request.body)\n        \n        # Perform security checks\n        result = {\n            'valid': True,\n            'checks': {\n                'rate_limit': True,\n                'input_validation': True,\n                'authentication': request.user.is_authenticated\n            }\n        }\n        \n        return JsonResponse(result)\n        \n    except json.JSONDecodeError:\n        return JsonResponse({'error': 'Invalid JSON'}, status=400)\n    except Exception as e:\n        logger.error(f"Security check error: {str(e)}")\n        return JsonResponse({'error': 'Security check failed'}, status=500)